// write into a polygon
	gpc_polygon * outputs = malloc(1*sizeof(gpc_polygon));
	outputs->hole = NULL;
	outputs->num_contours = 1;
	outputs->contour = malloc(1*sizeof(gpc_vertex_list));
	outputs->contour->num_vertices = (out->numberofsegments -1);
	outputs->contour->vertex = malloc(outputs->contour->num_vertices*sizeof(gpc_vertex));

	for ( int i = 0 ; i <  outputs->contour->num_vertices ; ++i )
	{
		outputs->contour->vertex[i].x = out->pointlist[2*(connected_segments[2*i]-1)];
		outputs->contour->vertex[i].y = out->pointlist[2*(connected_segments[2*i]-1) + 1];

	}


    // create a jc voronoi structure
	jcv_diagram diagram;
	jcv_graphedge * graph_edge;
	memset(&diagram, 0, sizeof(jcv_diagram));



	// generate voronoi diagram
	for (int i = 0; i < out->numberofpoints; ++i)
	{
		points[i].x = out->pointlist[2*i];
		points[i].y = out->pointlist[2*i+1];

		/* code */
	}

	// GENERATE VORONOI DIAGRAM
	printf("Generating voronoi diagram \n");
	jcv_diagram_generate(out->numberofpoints,(const jcv_point *) points, NULL, &diagram);

	//VORONOI DIAGRAM //

	gpc_polygon **voronoi = malloc(diagram.numsites*sizeof(gpc_polygon *));

	for (int i = 0; i < diagram.numsites; ++i)
	{
		// Initialise polgon
		voronoi[i] = malloc(1*sizeof(gpc_polygon));
		voronoi[i]->hole = NULL;
		voronoi[i]->num_contours = 1;
		voronoi[i]->contour = malloc(1*sizeof(gpc_vertex_list));
		voronoi[i]->contour->num_vertices = 0;
		voronoi[i]->contour->vertex = malloc(voronoi[i]->contour->num_vertices*sizeof(gpc_vertex));

	}



	// LOOP OVER EACH SITE
	char fileName1[256];
 	const jcv_site* sites;
  	sites = jcv_diagram_get_sites(&diagram);
    int vertCount = 0;

  	// start of loop
  	printf("Clipping edges of cells\n");
	for (int i=0; i<diagram.numsites; ++i) {

	vertCount = 0;
    graph_edge = sites[i].edges;
    voronoi[i]->index = sites[i].index;

    if ( out->pointattributelist == NULL)
    	voronoi[i]->attribute = out->pointattributelist[voronoi[i]->index];


    // FIRST GET NUMBER OF EDGES IN THE CELL

    while (graph_edge) {
    	++vertCount;
    	graph_edge = graph_edge->next;

    }// end of while loop over edges

    // create memory for the voronoi cell
    voronoi[i]->contour->num_vertices = vertCount;
	voronoi[i]->contour->vertex = malloc(voronoi[i]->contour->num_vertices*sizeof(gpc_vertex));

	// loop of the edges of the site
    graph_edge = sites[i].edges;
    for (int k = 0; k < vertCount; ++k)
    {
    	// loop over each cell and put it into the voronoi polygon structure
    	voronoi[i]->contour->vertex[k].x = graph_edge->pos[0].x;
    	voronoi[i]->contour->vertex[k].y = graph_edge->pos[0].y;
    	graph_edge = graph_edge->next;
    }// end of loop over edges


	// clip the cell
	gpc_polygon * result1 = malloc(1*sizeof(gpc_polygon));

	gpc_polygon_clip(GPC_INT, outputs, voronoi[i], result1);

	gpc_free_polygon(voronoi[i]);
	voronoi[i] = result1;


	// write cell to file
	snprintf(fileName1,sizeof(fileName1),"./Cells/%d.txt",i);
	// write clipped cell to files
	fp = fopen(fileName1,"w");
	if ( fp != NULL)
		gpc_write_polygon(fp, 0, voronoi[i]);
	fclose(fp);

	}// end of loop of sites

	printf("success..\n");

	fp = fopen("cells.txt","w");
	gpc_write_polygon(fp, 0, outputs);
	// in point list,
	FILE * ptr;
	ptr = fopen("mesh.1.ele","w");
	fprintf(ptr,"%i %i %i \n",out->numberoftriangles,3,0 );
	for(int i = 0 ; i < out->numberoftriangles ; i ++){
		fprintf(ptr,"%i %i %i %i\n",i+1,out->trianglelist[3*i],out->trianglelist[3*i +1 ], out->trianglelist[3*i+2]);
	}
	fclose(ptr);


	ptr = fopen("mesh.1.node","w");
	fprintf(ptr,"%i %i %i %i\n",out->numberofpoints,2,0,0 );
	for (int i = 0 ; i < out->numberofpoints ; i++){
		fprintf(ptr,"%i %lf %lf \n",i+1,out->pointlist[2*i],out->pointlist[2*i+1]);

	}
	fclose(ptr);



	// set outputs
	*voronoi_out = voronoi;
	*points_out = points;
	*numPoints = out->numberofpoints;
	*boundary = connected_segments;
	// need to free the input and output memory of tri; the only thing that needs to come out
	// is jcv_points and


